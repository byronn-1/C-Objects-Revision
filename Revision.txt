Object Orientated Programming With C#
---------------------------------------

Objects relate to real Objects

Objects have- attributes and behaviours


********************
TYPES-----

Every object in C# is of a different type. In C# every value that a variable can take on is an object.  

TYPES examples-- int, double or string

we can create our own types though, thats what classes are for...

A Class is a template for making individual objects of a particular type.

(we can use "type" and "class" interchangably)

Remember the cookie cutter analogy
cookie-cutter = class
cookie = object


*******************
INSTANTIATION----

basically any thing that is a noun can be declared as an object tower...
Tower 
Path
Point
Invader
Map

Its important to remember that for example the Tower class is not a "tower" itself its just a template. To create an actual object we need to use this class to create an object of TYPE Tower.
to instantiate............
we first say what type of object it is...

Tower 

then give the object a name....

Tower bob

then we assign it a new variable

Tower bob = new Tower();

This creates a new variable called bob with a lower case "b" that is of type tower with an upper case "T" and assigns it an newly created Tower object ( Tower() )

So its convention to use upper case when naming classes because we can call the objects the same as their types or classes.

("object" and "instance" can be used interchanably)

Tower bob = new Tower();..........
here we instantiated an instantce from the tower class.

Just remember an object is an instance of a class.

heres an exmple of making a class for invader...

class Invader
{

}

NOTE: you dont have to make a seperate file for each class and you dont have to name the file as same as the class. This is just a convention.


**************
FIELDS----


To fill out a class we need to think about what types of attributes it has and then try to keep it to a minimum and keep it simple. E.G. with map there are two fields width and height. These fields will be declared right inside the class. We declare them simlarly to the way we declare variables inside of methods

first we give them a title

int 

then we give them a name 

int Width;

Before we assign them values we need to make them acessable to other classes.....

We have two access modifiers called 
Public and Private 

Private- Fields are only accesable to the same class that theyre declared in. (Unidentified Fields are private by default)

e.g.

public int Width;


-- When it comes to fields the rule of thimb is to make all fields private then write public getters and setters that access it indirectly.

This would force you to write alot of additional code for two methods for each field...........
In comes properties 

So instead of....
class Invader
    {
      private MapLocation _location;

      public MapLocation GetLocation()
      {
        return _location;
      }

      public void SetLocation(MapLocation value)
      {
        _location = value;
      }
    }
      we could do this.........
class Invader
{
       public MapLocation Location
      {
        get 
        {
          return _location;
        }
        set
        {
          _location = value;
        }
}

************************
OBJECT INSTANTIATION----

Constructor Methods- are special kind of methods that are used to construct new instances of a class. Constructor methods are named the same as the class they're in. 

For Example....

class Map 
{
 (1)  public int Width;
      public int Height;

  Map(int width, int height)
  {
   (2)  Width = width;
        Height = height;
  }
}

(1)... the width and Height Fields that are declared in 1  are instance variables and they exist as long as the instance is availiable

(2) These variables are called method level variables because they only exist inside this method. And you can only use these variables inside this method.

This is all about the variables scope the instance variables can be used by other methods and even other classes.

Remember..... Constructor methods can't return any thing so theres no need to put a return type or even Void.

You can put public on the constructor so other classes can constuct a Map using this constructor. 


****************
Methods----

So far we've only learnt about an objects attributes, we now need to look at what an object can do or behaviours. 

class Map 
{
  (1) public readonly int Width;
      public readonly int Height;

  (2) public Map(int width, int height)
  {
    Width = width;
    Height = height;
  }

  (3) public bool OnMap(Point point)
  {
          bool inBounds = point.X >= 0 &&
             point.X < Width && 
             point.Y >= 0 && 
             point.Y < Height;
      return inBounds;
  }

}
(3)........ is a method

******************
STATIC VS INSTANCE METHODS -----

Static Methods are called directly on the class we dont neeed to construct an object before we can use them.

e.g. 
Math.sqrt((area),2);

So here Math is capitalized because its the name of the math Class the suare root method is being called directly on the Math class theres no math object being used.


******************
USING STATIC METHODS-----
errrrrrrrrrrr!!!

******************
WRITING THE CONSTRUCTOR FOR THE PATH CLASS ----

So we need to think of the least amount of information its possble to model the path class. Soooo... Just the path location or MapLocations. We can pass these in as array of maploactions and store them as a field. Alought we arent going to let these be public.

using System;

namespace TreehouseDefense
{
  class Path
  {
    private MapLocation[] _path;
  
      public Path(MapLocation[] path)
      {
        _path = path;
      }
  }
}

The underscore helps to distinguish between instance variables and method variables. If we didnt have this wed either have to name these two variables differently (1) and (2).

using System;

namespace TreehouseDefense
{
  class Path
  {
    private MapLocation[] (1) _path;
  
      public Path(MapLocation[] (2)path)
      {
        _path = path;
      }
  }
}

or we'd have to type....

using System;

namespace TreehouseDefense
{
  class Path
  {
    private MapLocation[] _path;
  
      public Path(MapLocation[] path)
      {
        this.path = path;
      }
  }
}

READONLY----- 

Something to be noted about readonly is that it only prohibits overriding the field with a different value. It doesnst prohibit any one from changing the individual values in the ararry. Thats the reason we're wrapping the field in a class in the first place. By wrapping the array in a class and private to restrict access thers no way for users of this class to alter the path.

We've now used encapsulation to hide the array of maplocations 

*******************
TERNARY IF -------

      public GetLocationAt(int pathStep)
      {
        if(pathStep < _path.Length)
        {
          return _path[pathStep];
        }
        else
        {
          return null;
        }

becomes......

      public GetLocationAt(int pathStep)
      {
        return (pathStep < _path.Length) ? _path[pathStep] : null;
      }


*********************
GETTERS AND SETTERS WITH CLASSES -----